<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>k8s-eventbroadcaster | l0calh0st</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">k8s-eventbroadcaster</h1><a id="logo" href="/.">l0calh0st</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">k8s-eventbroadcaster</h1><div class="post-meta">2021-04-20</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#0x00-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">0x00 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x01-EventBroadCaster%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">0x01 EventBroadCaster事件管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x01-EventBroadCaster%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">0x01 EventBroadCaster组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x02-broadcasterWatcher"><span class="toc-number">4.</span> <span class="toc-text">0x02 broadcasterWatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x03-Recorder"><span class="toc-number">5.</span> <span class="toc-text">0x03 Recorder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x04-%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">0x04 总结</span></a></li></ol></div></div><div class="post-content"><h4 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h4><p>&emsp; <code>Event</code>是k8s一种重要的资源对象，k8s重要的组件基本都是基于event事件来作出相对应反映，驱动着整个k8s集群的运作。但是event 是如何产生的？如何上报给k8s APIserver？</p>
<h4 id="0x01-EventBroadCaster事件管理器"><a href="#0x01-EventBroadCaster事件管理器" class="headerlink" title="0x01 EventBroadCaster事件管理器"></a>0x01 EventBroadCaster事件管理器</h4><p>&emsp; k8s通过<code>EventBroadCaster</code>事件管理器来将客户端生成的event传递给上游(<code>apiserver</code>/<code>log</code>….),在这个管理器里面有三个重要的组件：</p>
<ul>
<li>EventRecorder:  事件产生者，k8s里面的组件都是通过EventRecorder 来记录他们所关心的事件</li>
<li>EventBroadCaster: 事件广播器，事件消费者，主要是将事件分发给和他们建立连接的<code>broadcasterWatcher</code>,目前主要有两种分发机制:<code>Blocking</code>和<code>NonBlocking</code>默认情况下是<code>NonBlocking</code>的</li>
<li>broadcasterWatcher: 事件观察者，主要用来从<code>EventBroadCaster</code>接收event，并做相应的处理(对event做聚合,过滤,上传APIserver/log等)</li>
</ul>
<p>具体流程如下图所示:<br><img src="/2021/04/20/k8s-eventbroadcaster/0x00.jpg" alt="event-flow"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartLogging(logrus.Infof)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;v1.EventSinkImpl&#123;Interface: clientset.CoreV1().Events(<span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: <span class="string">&quot;ExampleEvent&quot;</span>&#125;)</span><br><span class="line">pod,_ := clientset.CoreV1().Pods(metav1.NamespaceAll).Get(<span class="string">&quot;xxxx&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line">recorder.Event(pod, corev1.EventTypeNormal, <span class="string">&quot;event reason&quot;</span>, <span class="string">&quot;event message&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面分别解析三个组件</p>
<h4 id="0x01-EventBroadCaster组件"><a href="#0x01-EventBroadCaster组件" class="headerlink" title="0x01 EventBroadCaster组件"></a>0x01 EventBroadCaster组件</h4><p>&emsp;<code>EventBroadCaster</code> 事件广播器，它是一个接口定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventBroadcaster knows how to receive events and send them to any EventSink, watcher, or log.</span></span><br><span class="line"><span class="keyword">type</span> EventBroadcaster <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 主要是初始化一个watcher并和EventBroadcaster做绑定</span></span><br><span class="line">	StartEventWatcher(eventHandler <span class="function"><span class="keyword">func</span><span class="params">(*v1.Event)</span>) <span class="title">watch</span>.<span class="title">Interface</span></span></span><br><span class="line">    <span class="comment">// 对event做处理，StartRecordingToSink会调用StartEventWatcher</span></span><br><span class="line">	StartRecordingToSink(sink EventSink) watch.Interface</span><br><span class="line">    <span class="comment">// 将event上报给日志</span></span><br><span class="line">	StartLogging(logf <span class="function"><span class="keyword">func</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span>) <span class="title">watch</span>.<span class="title">Interface</span></span></span><br><span class="line">    <span class="comment">// 创建一个recorder</span></span><br><span class="line">	NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子的第一行代码<code>eventBroadcaster := record.NewBroadcaster()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBroadcaster</span><span class="params">(queueLength <span class="keyword">int</span>, fullChannelBehavior FullChannelBehavior)</span> *<span class="title">Broadcaster</span></span> &#123;</span><br><span class="line">	m := &amp;Broadcaster&#123;</span><br><span class="line">		watchers:            <span class="keyword">map</span>[<span class="keyword">int64</span>]*broadcasterWatcher&#123;&#125;,</span><br><span class="line">		incoming:            <span class="built_in">make</span>(<span class="keyword">chan</span> Event, incomingQueueLength),</span><br><span class="line">		watchQueueLength:    queueLength,</span><br><span class="line">		fullChannelBehavior: fullChannelBehavior,</span><br><span class="line">	&#125;</span><br><span class="line">	m.distributing.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> m.loop()</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码其实就是New一个Broadcaster 事件广播器，并且初始化一个<code>watchers</code>和<code>incoming</code>的缓冲channel， 然后在执行一个<code>loop</code>的goroutine,这个<code>loop</code>的goroutine主要负责从<code>incoming</code>管道里面接收event，再发送给注册到broadcaster的watchers,可以看下它具体的实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从incoming 接收到event</span></span><br><span class="line">	<span class="keyword">for</span> event := <span class="keyword">range</span> m.incoming &#123;</span><br><span class="line">		<span class="keyword">if</span> event.Type == internalRunFunctionMarker &#123;</span><br><span class="line">			<span class="comment">// 如果event类型是内部的类型，那么则跳过</span></span><br><span class="line">			event.Object.(functionFakeRuntimeObject)()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将event分发给watchers</span></span><br><span class="line">		m.distribute(event)</span><br><span class="line">	&#125;</span><br><span class="line">	m.closeAll()</span><br><span class="line">	m.distributing.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面代码可以看出上面对loop的描述，<code>loop</code>主要从<code>m.incoming</code> 的channel里面接收<code>Event</code>，在通过<code>m.distribute</code>函数将<code>Event</code>分发出去，但是具体分发给谁？看下<code>distribute</code>函数的实现：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">distribute</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.fullChannelBehavior == DropIfChannelFull &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的watcher，将event写入watcher的result写管道</span></span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 将event发送给watcher</span></span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;-w.stopped:</span><br><span class="line">			<span class="keyword">default</span>: <span class="comment">// Don&#x27;t block if the event can&#x27;t be queued.</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;-w.stopped:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过上面流程可以看出<code>EventBroadcaster</code>主要做的事情: 创建一个<code>Broadcaster</code>,并且创建一个<code>incoming</code>的缓冲channel，和<code>broadcasterWatcher</code>, 然后开启一个goroutine，负责从<code>incoming</code>读取event，再写入所有注册到<code>Broadcaster</code>的eventwatcher的result写管道里面.</p>
</blockquote>
<p>流程图如下:<br><img src="/2021/04/20/k8s-eventbroadcaster/0x01.jpeg" alt="broadcaster-flow"></p>
<h4 id="0x02-broadcasterWatcher"><a href="#0x02-broadcasterWatcher" class="headerlink" title="0x02 broadcasterWatcher"></a>0x02 broadcasterWatcher</h4><p>&emsp;<code>broadcasterWatcher</code>主要负责接收来自<code>EventBroadcaster</code>的event，然后放到<code>eventHandler</code>里面做相应的处理, <code>broadcasterWatcher</code>主要是通过<code>EventBroadcaster</code>里面<code>StartRecordingToSink</code>这个函数来创建，看下 <code>StartRecordingToSink</code>函数的具体实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eventBroadcaster *eventBroadcasterImpl)</span> <span class="title">StartRecordingToSink</span><span class="params">(sink EventSink)</span> <span class="title">watch</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">	randGen := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    <span class="comment">// 创建一个eventCorrlator</span></span><br><span class="line">	eventCorrelator := NewEventCorrelatorWithOptions(eventBroadcaster.options)</span><br><span class="line">    <span class="comment">// 调用eventBroadcaster.StartEventWatcher 函数，函数参数是一个eventhandler函数</span></span><br><span class="line">	<span class="keyword">return</span> eventBroadcaster.StartEventWatcher(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(event *v1.Event)</span></span> &#123;</span><br><span class="line">			recordToSink(sink, event, eventCorrelator, randGen, eventBroadcaster.sleepDuration)</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们发现<code>StartRecordingToSink</code>这个函数主要就是做了两件事情1: 创建了一个eventCorrator 2. 调用<code>eventBroadcaster.StartEventWatcher</code>函数，到这里我们其实还是不清楚<code>eventBroadcastwatcher</code>是如何工作的，以及这个<code>broadcasterWatcher</code> 到底是个啥， 继续看下<code>StartEventWatcher</code>这个函数的具体实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eventBroadcaster *eventBroadcasterImpl)</span> <span class="title">StartEventWatcher</span><span class="params">(eventHandler <span class="keyword">func</span>(*v1.Event)</span>) <span class="title">watch</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用eventBroadcaster.Watch()函数</span></span><br><span class="line">	watcher := eventBroadcaster.Watch()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">        <span class="comment">// 从watcher.ResultChan()管道读取event object</span></span><br><span class="line">		<span class="keyword">for</span> watchEvent := <span class="keyword">range</span> watcher.ResultChan() &#123;</span><br><span class="line">			event, ok := watchEvent.Object.(*v1.Event)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">// This is all local, so there&#x27;s no reason this should</span></span><br><span class="line">				<span class="comment">// ever happen.</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 将读取到的event传递给eventHandler来做进一步处理，我们可以在之前StartRecordSink函数里面可以发现，这个eventhandler 就是recordEventSink函数 </span></span><br><span class="line">			eventHandler(event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> watcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码里面有两部分是重要的<code>eventBroadcaster.Watch()</code>和<code>eventHandler(event)</code>这两个函数，在看具体函数实现之前，先说明下这两个函数的主要做了那些事情:<code>eventBroadcaster.Watch()</code>这个函数主要是创建一个<code>broadcasterWatcher</code>,并且把这个<code>broadcasterWatcher</code>和<code>EventBroadcaster</code>关联起来，<code>eventHandler(event)</code>这个函数主要负责具体针对event做一些处理(对event做一些过滤,聚合,发送到apiserver)，下面看下具体函数的实现,先看下<code>eventBroadcaster.Watch()</code>这段代码的具体实现</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Watch</span><span class="params">()</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的broadcasterWatcher, 并且返回这个broadcaster</span></span><br><span class="line">	<span class="keyword">var</span> w *broadcasterWatcher</span><br><span class="line">	m.blockQueue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		m.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">		id := m.nextWatcher</span><br><span class="line">		m.nextWatcher++</span><br><span class="line">		w = &amp;broadcasterWatcher&#123;</span><br><span class="line">			result:  <span class="built_in">make</span>(<span class="keyword">chan</span> Event, m.watchQueueLength),</span><br><span class="line">			stopped: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">			id:      id,</span><br><span class="line">			m:       m,</span><br><span class="line">		&#125;</span><br><span class="line">		m.watchers[id] = w</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ok,我们可以看到这段代码其实就创建了一个<code>broadcasterWatcher</code>，<code>blockQueue</code>的作用就是清空<code>incoming</code>channel，以确保在<code>broadcasterWatcher</code>在启动之前<code>incoming</code>里面没有任何event事件， 下面在看下<code>eventHandler(event)</code>这个具体实现，上面我们以及说过<code>eventHandler</code> 在<code>StartRecordingToSink</code>里面就是<code>recordToSink</code>这个函数，因此我们需要看的函数代码是<code>recordToSink</code>函数的具体实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordToSink</span><span class="params">(sink EventSink, event *v1.Event, eventCorrelator *EventCorrelator, randGen *rand.Rand, sleepDuration time.Duration)</span></span> &#123;</span><br><span class="line">	eventCopy := *event</span><br><span class="line">	event = &amp;eventCopy</span><br><span class="line">    <span class="comment">// 通过生成的eventCorrelator.EventCorrelator对event做进一步的处理</span></span><br><span class="line">	result, err := eventCorrelator.EventCorrelate(event)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.Skip &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	tries := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 通过recordEvent 函数将Event发送给APIserver</span></span><br><span class="line">		<span class="keyword">if</span> recordEvent(sink, result.Event, result.Patch, result.Event.Count &gt; <span class="number">1</span>, eventCorrelator) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		tries++</span><br><span class="line">		<span class="keyword">if</span> tries &gt;= maxTriesPerEvent &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Unable to write event &#x27;%#v&#x27; (retry limit exceeded!)&quot;</span>, event)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tries == <span class="number">1</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(<span class="keyword">float64</span>(sleepDuration) * randGen.Float64()))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			time.Sleep(sleepDuration)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看代码的具体实现，这段函数里面其实主要就做了两件事情1 通过<code>eventCorrelator.EventCorrelate</code>对event做了一些聚合/过滤等处理操作，2.通过<code>recordEvent</code>将event发送给APIserver，。到了这个大概对eventwatcher有了一个大概的认知，总结下流程图如下:<br><img src="/2021/04/20/k8s-eventbroadcaster/0x02.jpg"></p>
</blockquote>
<h4 id="0x03-Recorder"><a href="#0x03-Recorder" class="headerlink" title="0x03 Recorder"></a>0x03 Recorder</h4><p>&emsp;<code>Recorder</code>相当于是event的生产者，从<code>EventBroadcaster</code>接口可以看到通过<code>NewRecorder</code>函数来创建一个<code>eventRecorder</code>， 看下<code>NewRecorder</code>函数的具体实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eventBroadcaster *eventBroadcasterImpl)</span> <span class="title">NewRecorder</span><span class="params">(scheme *runtime.Scheme, source v1.EventSource)</span> <span class="title">EventRecorder</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;recorderImpl&#123;scheme, source, eventBroadcaster.Broadcaster, clock.RealClock&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过代码可以发现，<code>NewRecorder</code>主要就是返回一个实现了<code>EventRecorder</code>接口的对象,<code>EventRecorder</code>的定义如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventRecorder <span class="keyword">interface</span> &#123;</span><br><span class="line">	Event(object runtime.Object, eventtype, reason, message <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	Eventf(object runtime.Object, eventtype, reason, messageFmt <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    AnnotatedEventf(object runtime.Object, annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, eventtype, reason, messageFmt <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口主要定义了record如何生成一个event，主要有上面描述四种方法，上面我们daemon里面使用<code>Event</code>这个方法来生成一个event， 我们看下event方法的具体实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recorder *recorderImpl)</span> <span class="title">Event</span><span class="params">(object runtime.Object, eventtype, reason, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	recorder.generateEvent(object, <span class="literal">nil</span>, metav1.Now(), eventtype, reason, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从函数的具体实现，我们可以发现<code>Event</code>方法主要调用了<code>recorder.generateEvent()</code>这个方法来生成event的，具体看下<code>recorder.generateEvent</code>的实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recorder *recorderImpl)</span> <span class="title">generateEvent</span><span class="params">(object runtime.Object, annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, timestamp metav1.Time, eventtype, reason, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	ref, err := ref.GetReference(recorder.scheme, object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Could not construct reference to: &#x27;%#v&#x27; due to: &#x27;%v&#x27;. Will not report event: &#x27;%v&#x27; &#x27;%v&#x27; &#x27;%v&#x27;&quot;</span>, object, err, eventtype, reason, message)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !util.ValidateEventType(eventtype) &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Unsupported event type: &#x27;%v&#x27;&quot;</span>, eventtype)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//创建一个event对象</span></span><br><span class="line">	event := recorder.makeEvent(ref, annotations, eventtype, reason, message)</span><br><span class="line">	event.Source = recorder.source</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">        <span class="comment">// 执行recorder.Action()函数</span></span><br><span class="line">		recorder.Action(watch.Added, event)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过具体的函数实现，我们可以发现，<code>generateEvent</code>这段函数主要就做了以下两件事情1 通过<code>makeEvent</code>函数来创建一个event对象，2 通过调用<code>recorder.Action()</code>函数来对生成的event做处理，具体<code>Action</code>是做啥看下它具体实现:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Action</span><span class="params">(action EventType, obj runtime.Object)</span></span> &#123;</span><br><span class="line">	m.incoming &lt;- Event&#123;action, obj&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>incoming</code>ok 到了这里我们就清楚了，recorder创建event的逻辑 创建event 对象，并且把这个对象写入到broadcaster的incoming channel里面</p>
</blockquote>
<h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>&emsp;通过上面对三个组建的分析，我们知道eventbroadcaster的具体工作逻辑<br>发送端/生成者： 创建event对象，将event对象写入到eventbroadcaster的incoming缓冲管道里面<br>消费者/eventbroadcaster，   eventbroadcaster 从incoming管道里面接收event，并把这个event发送给和它关联的watcher(将event写入到每个watcher里面result channel 里面)<br>观察者： watcher 从result管道里面读取event，并对event做一些处理，发送出去</p>
</div><div class="tags"><a href="/tags/k8s/"><i class="fa fa-tag"></i>k8s</a></div><div class="post-nav"><a class="pre" href="/2021/05/31/memory-allocator/">memory-allocator</a><a class="next" href="/2021/04/03/programming-kubernetes-part2/">programming-kubernetes-part2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://3xpl0it3r.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/csapp/" style="font-size: 15px;">csapp</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 15px;">面试题</a> <a href="/tags/k8s/" style="font-size: 15px;">k8s</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/memory/" style="font-size: 15px;">memory</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/31/memory-allocator/">memory-allocator</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/20/k8s-eventbroadcaster/">k8s-eventbroadcaster</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/03/programming-kubernetes-part2/">programming-kubernetes-part2</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/31/csapp-char1/">csapp-char1</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/28/go-bootstrap/">go启动流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/27/go-interface/">go-interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/program-k8s-1-introduce/">k8s编程-介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/15/golang-escape/">golang 逃逸机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/12/interview/">interview</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/hello-world/">hello-world</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">l0calh0st.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>