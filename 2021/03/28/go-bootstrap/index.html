<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>go启动流程分析 | l0calh0st</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">go启动流程分析</h1><a id="logo" href="/.">l0calh0st</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">go启动流程分析</h1><div class="post-meta">2021-03-28</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#0x00-golang-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">0x00 golang 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">初始化栈信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96CPU%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">获取CPU的信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96cgo"><span class="toc-number">1.3.</span> <span class="toc-text">初始化cgo</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEtls"><span class="toc-number">2.</span> <span class="toc-text">设置tls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tls%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">tls校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96TLS-%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">4.</span> <span class="toc-text">初始化TLS, 并进行双向绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.</span> <span class="toc-text">校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A9%E4%BD%99"><span class="toc-number">6.</span> <span class="toc-text">剩余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="post-content"><h4 id="0x00-golang-启动过程"><a href="#0x00-golang-启动过程" class="headerlink" title="0x00 golang 启动过程"></a>0x00 golang 启动过程</h4><p>&emsp;通过一段简单的demo来看下go 代码启动发生了啥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>首先先定位到启动入口函数</em></p>
<p><img src="/2021/03/28/go-bootstrap/0x00.png"></p>
<p>从断点信息可以看到在linux amd64位操作系统上面的入口函数在<code>/usr/lib/golang/src/runtime/rt0_linux_amd64.s:8</code>这个里面。amd64表示在amd64位系统上的实现。当然这个在不通的平台上面有不同的实现，可以在源代码目录看到有各种架构结尾的文件。<br><img src="/2021/03/28/go-bootstrap/0x01.jpg"><br>从调试界面可以看到<code>_rt0_amd64_linux</code> 最终jmp到<code>_rt0_amd64</code>这个函数里面执行，而<code>_rt0_amd64</code>这个函数位于<code>/usr/lib/golang/src/runtime/asm_amd64.s:15</code><br><img src="/2021/03/28/go-bootstrap/0x02.jpg"></p>
<p>打开对应的文件看下<code>_rt0_amd64</code>这个函数的实现,具体函数实现如下：<br><img src="/2021/03/28/go-bootstrap/0x03.jpg"><br>从注释里面可以看到这三行代码做的事情很简单了，将<code>argc</code>,<code>argv</code>这两个参数分别放到<code>DI</code>和<code>SI</code>这两个寄存器里面，然后在跳转到<code>runtime·rt0_go(SB)</code>这个地方去执行。</p>
<p>*runtime·rt0_go(SB)*函数<br>从调试界面可以看到rt0_go这个函数位于<code>/usr/lib/golang/src/runtime/asm_amd64.s:89</code>这个文件里面<br><img src="/2021/03/28/go-bootstrap/0x04.jpg"><br>具体代码如下<br><img src="/2021/03/28/go-bootstrap/0x05.jpg"><br>下面挨个看下rt0_go主要做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; copy arguments forward on an even stack</span><br><span class="line">MOVQ	DI, AX		&#x2F;&#x2F; argc</span><br><span class="line">MOVQ	SI, BX		&#x2F;&#x2F; argv</span><br><span class="line">SUBQ	$(4*8+7), SP		&#x2F;&#x2F; 2args 2auto</span><br><span class="line">ANDQ	$~15, SP</span><br><span class="line">MOVQ	AX, 16(SP)</span><br><span class="line">MOVQ	BX, 24(SP)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这几行代码主要做的事情，先把两个参数的偏移地址放到ax,bx寄存器里面，然后扩充栈空间，并且四六字节对齐下，最后再把那两个参数argc,argv的偏移地址放到栈上面。代码注释可以大致了解这段代码主要是将命令行参数拷贝到栈上。</p>
</blockquote>
<h5 id="初始化栈信息"><a href="#初始化栈信息" class="headerlink" title="初始化栈信息"></a>初始化栈信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create istack out of the given (operating system) stack.</span><br><span class="line">	&#x2F;&#x2F; _cgo_init may update stackguard.</span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(-64*1024+104)(SP), BX</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这段代码首先将g0的地址加载到<code>di</code>寄存器里面。然后将(sp-64*1024+107)(这个栈空间是干嘛的不清楚-，-)这个地方地址加载到BX里面，再将bx寄存器里面的值加载到<code>g_stackguard0(DI)</code>和<code>g_stackguard1(DI)</code>以及<code>(g_stack+stack_lo)(DI)</code>  这三个变量里面，将<code>SP</code>寄存器里面的内容加载到<code>(g_stack+stack_hi)(DI)</code>变量里面，参考着注释，大概意思可能用用一段操作系统分配的栈来初始化当前g0的栈。</p>
<blockquote>
<p><code>g0</code>是一个全局变量，类型是g,可以从代码里面看到g的结构体：<br><img src="/2021/03/28/go-bootstrap/0x07.jpg"></p>
</blockquote>
</blockquote>
<h5 id="获取CPU的信息"><a href="#获取CPU的信息" class="headerlink" title="获取CPU的信息"></a>获取CPU的信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F; find out information about the processor we&#39;re on</span><br><span class="line">	MOVL	$0, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, SI</span><br><span class="line">	CMPL	AX, $0</span><br><span class="line">	JE	nocpuinfo</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Figure out how to serialize RDTSC.</span><br><span class="line">	&#x2F;&#x2F; On Intel processors LFENCE is enough. AMD requires MFENCE.</span><br><span class="line">	&#x2F;&#x2F; Don&#39;t know about the rest, so let&#39;s do MFENCE.</span><br><span class="line">	CMPL	BX, $0x756E6547  &#x2F;&#x2F; &quot;Genu&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	DX, $0x49656E69  &#x2F;&#x2F; &quot;ineI&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	CX, $0x6C65746E  &#x2F;&#x2F; &quot;ntel&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	MOVB	$1, runtime·isIntel(SB)</span><br><span class="line">	MOVB	$1, runtime·lfenceBeforeRdtsc(SB)</span><br><span class="line">notintel:</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Load EAX&#x3D;1 cpuid flags</span><br><span class="line">	MOVL	$1, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, runtime·processorVersionInfo(SB)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码主要是获取CPU信息的，<code>CPUID</code>(这个玩意应该plan9提供的一个汇编指令),(盲猜cpuid这个指令获取的数据存放在bx,dx,cx这三个寄存器里面)，下面三个<code>CMPL</code>  指令主要ax,bx,cx三个寄存器组成的值(GenuineIntel)和<code>GenuineIntel</code>做对比，如果有一个不匹配的跳过</p>
</blockquote>
<h5 id="初始化cgo"><a href="#初始化cgo" class="headerlink" title="初始化cgo"></a>初始化cgo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nocpuinfo:</span><br><span class="line">	&#x2F;&#x2F; if there is an _cgo_init, call it.</span><br><span class="line">	MOVQ	_cgo_init(SB), AX</span><br><span class="line">	TESTQ	AX, AX</span><br><span class="line">	JZ	needtls</span><br><span class="line">	&#x2F;&#x2F; arg 1: g0, already in DI</span><br><span class="line">	MOVQ	$setg_gcc&lt;&gt;(SB), SI &#x2F;&#x2F; arg 2: setg_gcc</span><br><span class="line">#ifdef GOOS_android</span><br><span class="line">	MOVQ	$runtime·tls_g(SB), DX 	&#x2F;&#x2F; arg 3: &amp;tls_g</span><br><span class="line">	&#x2F;&#x2F; arg 4: TLS base, stored in slot 0 (Android&#39;s TLS_SLOT_SELF).</span><br><span class="line">	&#x2F;&#x2F; Compensate for tls_g (+16).</span><br><span class="line">	MOVQ	-16(TLS), CX</span><br><span class="line">#else</span><br><span class="line">	MOVQ	$0, DX	&#x2F;&#x2F; arg 3, 4: not used when using platform&#39;s TLS</span><br><span class="line">	MOVQ	$0, CX</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_windows</span><br><span class="line">	&#x2F;&#x2F; Adjust for the Win64 calling convention.</span><br><span class="line">	MOVQ	CX, R9 &#x2F;&#x2F; arg 4</span><br><span class="line">	MOVQ	DX, R8 &#x2F;&#x2F; arg 3</span><br><span class="line">	MOVQ	SI, DX &#x2F;&#x2F; arg 2</span><br><span class="line">	MOVQ	DI, CX &#x2F;&#x2F; arg 1</span><br><span class="line">#endif</span><br><span class="line">	CALL	AX</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; update stackguard after _cgo_init</span><br><span class="line">	MOVQ	$runtime·g0(SB), CX</span><br><span class="line">	MOVQ	(g_stack+stack_lo)(CX), AX</span><br><span class="line">	ADDQ	$const__StackGuard, AX</span><br><span class="line">	MOVQ	AX, g_stackguard0(CX)</span><br><span class="line">	MOVQ	AX, g_stackguard1(CX)</span><br><span class="line"></span><br><span class="line">#ifndef GOOS_windows</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">needtls:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一整段都是设置cgo相关的，从代码注释里面可以看到，只有当启用cgo的时候才会调用这段代码，否则直接跳转到<code>needtls</code>这段里面继续执行，(cgo? 从来没用过，这段代码拜拜)</p>
</blockquote>
<h4 id="设置tls"><a href="#设置tls" class="headerlink" title="设置tls"></a>设置tls</h4><p>&emsp;代码的165-181主要是判断操作系统是否支持tls，如果匹配到对应的操作系统(也就这些操作系统不支持TLS),那么则跳过tls相关的设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">needtls:</span><br><span class="line">#ifdef GOOS_plan9</span><br><span class="line">	&#x2F;&#x2F; skip TLS setup on Plan 9</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_solaris</span><br><span class="line">	&#x2F;&#x2F; skip TLS setup on Solaris</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_illumos</span><br><span class="line">	&#x2F;&#x2F; skip TLS setup on illumos</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_darwin</span><br><span class="line">	&#x2F;&#x2F; skip TLS setup on Darwin</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">	CALL	runtime·settls(SB)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; store through it, to make sure it works</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$0x123, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $0x123</span><br><span class="line">	JEQ 2(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tls的设置对应着代码的182-192行<br>先看下183-184行这两行代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">CALL	runtime·settls(SB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码先将m0+m_tls的地址加载到,di寄存器里面，然后在调用<code>runtime.settls</code><br>首先<code>runtime.m0+m_tls</code>这个地址代表啥意思？和上面<code>g0</code>一样，<code>m0</code>也是一个全局变量，这里的代码意思就是将<code>m0</code>这个变量的<code>tls</code>这个字段的地址加载到<code>di</code>寄存器里面。可以在源代码里面看到<code>m0</code>这个变量对应的类型是<code>m</code><br><img src="/2021/03/28/go-bootstrap/0x08.jpg"></p>
</blockquote>
<p>下面我们继续看下<code>settls</code>这个函数里面具体干了啥，首选我们需要找到这段代码的位置这段函数在<code>sys_linux_amd64.s:TEXT runtime·settls(SB),NOSPLIT,$32 </code>里面。代码如下:<br><img src="/2021/03/28/go-bootstrap/0x09.jpg"><br>从注释里面看，这段代码(666行)位FS寄存器设置一个偏移地址(0x1002),然后执行一个系统调用(<code>SYS_arch_prctl</code>), 然后这<code>$0xfffffffffffff001</code>这个里面的值对比，如果不匹配则crash掉,(<code>$0xfffffffffffff001</code>这段值干嘛的我也不知道-，-)<br><code>int arch_prctl(int code, unsigned long addr)</code>这代码应该调用这个函数——-（有段有点迷糊，有懂得大佬可以指点下）<br>但是从反汇编的代码可以看到<br><img src="/2021/03/28/go-bootstrap/0x0C.jpg"><br>以及对应的AT&amp;T汇编代码<br><img src="/2021/03/28/go-bootstrap/0x0A.jpg"><br>基本可以猜测这段汇编代码对应的就是 <code>MOVQ    (TLS), CX</code>这段指令。</p>
<h4 id="tls校验"><a href="#tls校验" class="headerlink" title="tls校验"></a>tls校验</h4><p>继续返回主流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get_tls(BX)</span><br><span class="line">	MOVQ	$0x123, g(BX)               ; 将 0x123放到g里面</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX  ; 将tls的信息存放到AX里面</span><br><span class="line">	CMPQ	AX, $0x123                  ; 将AX(也就是之前初始化tls的信息)和0x123做对比</span><br><span class="line">	JEQ 2(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码应该是对tls做校验, 0x123是测试数据，主要验证tls是否work起来</p>
</blockquote>
<h4 id="初始化TLS-并进行双向绑定"><a href="#初始化TLS-并进行双向绑定" class="headerlink" title="初始化TLS, 并进行双向绑定"></a>初始化TLS, 并进行双向绑定</h4><p><em>绑定是g0和m0进行绑定</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ok:</span><br><span class="line">	&#x2F;&#x2F; set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class="line">    &#x2F;&#x2F; 获取tls的信息</span><br><span class="line">	get_tls(BX)</span><br><span class="line">    &#x2F;&#x2F; 加载g0的地址到cx寄存器里面，</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">    &#x2F;&#x2F; g里面的值是0x123, cx是g0的地址，</span><br><span class="line">    &#x2F;&#x2F; 将cx的值放到g里面&#x3D;&#x3D;&#x3D;&#x3D;这个就是用g0来填充tls里面信息,</span><br><span class="line">    &#x2F;&#x2F; 之前0x123是测试数据，到了这里就需要用g0来填充了</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">     &#x2F;&#x2F;  加载m0的地址到AX里面</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将g0赋值给m_g0</span><br><span class="line">	&#x2F;&#x2F; save m-&gt;g0 &#x3D; g0</span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	&#x2F;&#x2F; save m0 to g0-&gt;m</span><br><span class="line">    &#x2F;&#x2F; 将m0赋值给go-&gt;m</span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码应该就是做双向绑定, 首先在初始化tls之后,用g0信息来填充TLS<br>将m0-&gt;g0 = g0, g0-&gt;m = m0</p>
</blockquote>
<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CLD				&#x2F;&#x2F; convention is D is always left cleared</span><br><span class="line">CALL	runtime·check(SB)</span><br></pre></td></tr></table></figure>
<h4 id="剩余"><a href="#剩余" class="headerlink" title="剩余"></a>剩余</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CLD				&#x2F;&#x2F; convention is D is always left cleared</span><br><span class="line">CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">MOVL	16(SP), AX		&#x2F;&#x2F; copy argc</span><br><span class="line">MOVL	AX, 0(SP)</span><br><span class="line">MOVQ	24(SP), AX		&#x2F;&#x2F; copy argv</span><br><span class="line">MOVQ	AX, 8(SP)</span><br><span class="line">   &#x2F;&#x2F;  调用runtime.args 主要做参数校验的</span><br><span class="line">CALL	runtime·args(SB)</span><br><span class="line">   &#x2F;&#x2F;  os初始化</span><br><span class="line">CALL	runtime·osinit(SB)</span><br><span class="line">   &#x2F;&#x2F; scheduler初始化</span><br><span class="line">CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a new goroutine to start program</span><br><span class="line">   &#x2F;&#x2F; 将main.pc放到ax里面</span><br><span class="line">MOVQ	$runtime·mainPC(SB), AX		&#x2F;&#x2F; entry</span><br><span class="line">PUSHQ	AX</span><br><span class="line">PUSHQ	$0			&#x2F;&#x2F; arg size</span><br><span class="line">   &#x2F;&#x2F; 创建一个新的goroutine</span><br><span class="line">CALL	runtime·newproc(SB)</span><br><span class="line">POPQ	AX</span><br><span class="line">POPQ	AX</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start this M</span><br><span class="line">   &#x2F;&#x2F;  启动m(goroutime是调度到m上才会执行)</span><br><span class="line">CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">CALL	runtime·abort(SB)	&#x2F;&#x2F; mstart should never return</span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevent dead-code elimination of debugCallV1, which is</span><br><span class="line">&#x2F;&#x2F; intended to be called by debuggers.</span><br><span class="line">MOVQ	$runtime·debugCallV1(SB), AX</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p> 汇编看着头大，os初始化，scheduler后续在慢慢看</p>
</blockquote>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;由于这篇文章起源于群里面一个问题<code>当运行main.main()</code>整个流程是怎么用的。<br>现在简单回答下：当启动一个go程序的时候，大概的流程如下几件事情:</p>
<ul>
<li>先为g0初始化栈空间</li>
<li>保存命令参数，获取cpu信息(盲猜应该是用于设置GOMAXPROCS的)</li>
<li>设置tls，并且双向绑定m0(即将m0和g0双向绑定)</li>
<li>对参数进行校验 </li>
<li>初始化系统信息(内存/垃圾回收……)</li>
<li>初始化调度器</li>
<li>创建一个新的goroutine(用于运行用户的代码)</li>
<li>启动m</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><img src="http://www.hechaku.com/unix_linux/arch_prctl.html" alt="http://www.hechaku.com/unix_linux/arch_prctl.html"><br><img src="https://golang.org/doc/asm" alt="https://golang.org/doc/asm"><br><img src="https://studygolang.com/articles/2917" alt="https://studygolang.com/articles/2917"><br><img src="https://www.luozhiyun.com/archives/448" alt="https://www.luozhiyun.com/archives/448"></p>
</div><div class="tags"><a href="/tags/go/"><i class="fa fa-tag"></i>go</a></div><div class="post-nav"><a class="next" href="/2021/03/27/go-interface/">go-interface</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://3xpl0it3r.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 15px;">面试题</a> <a href="/tags/k8s/" style="font-size: 15px;">k8s</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/28/go-bootstrap/">go启动流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/27/go-interface/">go-interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/program-k8s-1-introduce/">k8s编程-介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/15/golang-escape/">golang 逃逸机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/12/interview/">interview</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/hello-world/">hello-world</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">l0calh0st.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>